function x=localSearch(funcToOptimize,proposalFunc,startingX,epsilon,lowerBoundOnX,upperBoundOnX,timeDelta,funcDelta)

% This general-purpose optimization routine aims to minimize funcToOptimize
% starting from the initial guess startingX, via proposals generated by
% proposalFunc (the two functions are specified via function handles).
%
% When optimizing a function whose inputs have lower and upper bounds, the
% proposal xp=proposalFunc(x) has all of its entries less than
% lowerBoundOnX rounded up to lowerBoundOnX, and all of its entries greater
% than upperBoundOnX rounded up to upperBoundOnX before funcToOptimize is
% evaluted on xp (these bounds can be -inf and +inf to make them effectively 
% ignored. 
%
% The proposal is accepted if it improves the function value, or does
% not make it worse by more than epsilon. The routine terminates when timeDelta
% seconds have passed without the best value found so far of funcToOptimize
% improving by funcDelta.

set(0, 'RecursionLimit', 2000);

starttime = now * 60 * 60 * 24;
timeout = 0;
accepted = 0;
timeAllowed = timeDelta;
funcOrig = funcToOptimize(startingX);

while timeout == 0
    % check boundary
    xp = proposalFunc(startingX);
    while min(min(xp)) < lowerBoundOnX || max(max(xp)) > upperBoundOnX
        xp = proposalFunc(startingX);
    end
        
    % evaluate proposed value's improvement
    funcProp = funcToOptimize(xp);
    valueDelta = funcProp - funcOrig;
    if valueDelta < 0 || (valueDelta >= 0 && valueDelta <= epsilon)
        % break the while loop if we found the improved 'xp'
        accepted = 1;
        break
    end

    % evaluate the time limit
    timenow = now * 60 * 60 * 24;
    timeAllowed = timeAllowed - (timenow - starttime);
    starttime = timenow;
    if timeAllowed < 0 
        timeout = 1;
    end
end

% timeDelta seconds have passed and the best value found in this stack imrpoves not much
if timeout == 1 && abs(valueDelta) / funcOrig <= funcDelta
    if accepted == 1
        x = xp;
    else
        x = startingX;
    end
else
    x = localSearch(funcToOptimize, proposalFunc, xp, epsilon, lowerBoundOnX, upperBoundOnX, timeDelta, funcDelta);
end
